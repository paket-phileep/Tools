"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createNodesV2 = void 0;
const devkit_1 = require("@nx/devkit");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const globs_1 = require("nx/src/utils/globs");
const workspace_context_1 = require("nx/src/utils/workspace-context");
const config_file_1 = require("../utils/config-file");
const resolve_eslint_class_1 = require("../utils/resolve-eslint-class");
const semver_1 = require("semver");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const file_hasher_1 = require("nx/src/hasher/file-hasher");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const DEFAULT_EXTENSIONS = ['ts', 'tsx', 'js', 'jsx', 'html', 'vue'];
const ESLINT_CONFIG_GLOB = (0, globs_1.combineGlobPatterns)([
    ...config_file_1.ESLINT_CONFIG_FILENAMES.map((f) => `**/${f}`),
]);
function readTargetsCache(cachePath) {
    return (0, node_fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache(cachePath, results) {
    (0, devkit_1.writeJsonFile)(cachePath, results);
}
const internalCreateNodes = async (configFilePath, options, context, projectsCache) => {
    options = normalizeOptions(options);
    const configDir = (0, node_path_1.dirname)(configFilePath);
    // Ensure that configFiles are set, e2e-run fails due to them being undefined in CI (does not occur locally)
    // TODO(JamesHenry): Further troubleshoot this in CI
    context.configFiles = context.configFiles ?? [];
    // Create a Set of all the directories containing eslint configs, and a
    // list of globs to exclude from child projects
    const eslintRoots = new Set();
    const nestedEslintRootPatterns = [];
    for (const configFile of context.configFiles) {
        const eslintRootDir = (0, node_path_1.dirname)(configFile);
        eslintRoots.add(eslintRootDir);
        if (eslintRootDir !== configDir && isSubDir(configDir, eslintRootDir)) {
            nestedEslintRootPatterns.push(`${eslintRootDir}/**/*`);
        }
    }
    const projectFiles = await (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, ['project.json', 'package.json', '**/project.json', '**/package.json'].map((f) => (0, node_path_1.join)(configDir, f)), nestedEslintRootPatterns.length ? nestedEslintRootPatterns : undefined);
    // dedupe and sort project roots by depth for more efficient traversal
    const dedupedProjectRoots = Array.from(new Set(projectFiles.map((f) => (0, node_path_1.dirname)(f)))).sort((a, b) => (a !== b && isSubDir(a, b) ? -1 : 1));
    const excludePatterns = dedupedProjectRoots.map((root) => `${root}/**/*`);
    const ESLint = await (0, resolve_eslint_class_1.resolveESLintClass)((0, config_file_1.isFlatConfig)(configFilePath));
    const eslintVersion = ESLint.version;
    const childProjectRoots = new Set();
    const projects = {};
    await Promise.all(dedupedProjectRoots.map(async (childProjectRoot, index) => {
        // anything after is either a nested project or a sibling project, can be excluded
        const nestedProjectRootPatterns = excludePatterns.slice(index + 1);
        // Ignore project roots where the project does not contain any lintable files
        const lintableFiles = await (0, workspace_context_1.globWithWorkspaceContext)(context.workspaceRoot, [(0, node_path_1.join)(childProjectRoot, `**/*.{${options.extensions.join(',')}}`)], 
        // exclude nested eslint roots and nested project roots
        [...nestedEslintRootPatterns, ...nestedProjectRootPatterns]);
        const parentConfigs = context.configFiles.filter((eslintConfig) => isSubDir(childProjectRoot, (0, node_path_1.dirname)(eslintConfig)));
        const hash = await (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(childProjectRoot, options, context, [...parentConfigs, (0, node_path_1.join)(childProjectRoot, '.eslintignore')]);
        if (projectsCache[hash]) {
            // We can reuse the projects in the cache.
            Object.assign(projects, projectsCache[hash]);
            return;
        }
        const eslint = new ESLint({
            cwd: (0, node_path_1.join)(context.workspaceRoot, childProjectRoot),
        });
        for (const file of lintableFiles) {
            if (!(await eslint.isPathIgnored((0, node_path_1.join)(context.workspaceRoot, file)))) {
                childProjectRoots.add(childProjectRoot);
                break;
            }
        }
        const uniqueChildProjectRoots = Array.from(childProjectRoots);
        const projectsForRoot = getProjectsUsingESLintConfig(configFilePath, uniqueChildProjectRoots, eslintVersion, options, context);
        if (Object.keys(projectsForRoot).length > 0) {
            Object.assign(projects, projectsForRoot);
            // Store those projects into the cache;
            projectsCache[hash] = projectsForRoot;
        }
    }));
    return {
        projects,
    };
};
exports.createNodesV2 = [
    ESLINT_CONFIG_GLOB,
    async (configFiles, options, context) => {
        const optionsHash = (0, file_hasher_1.hashObject)(options);
        const cachePath = (0, node_path_1.join)(cache_directory_1.workspaceDataDirectory, `eslint-${optionsHash}.hash`);
        const targetsCache = readTargetsCache(cachePath);
        try {
            return await (0, devkit_1.createNodesFromFiles)((configFile, options, context) => internalCreateNodes(configFile, options, context, targetsCache), configFiles, options, context);
        }
        finally {
            writeTargetsToCache(cachePath, targetsCache);
        }
    },
];
exports.createNodes = [
    ESLINT_CONFIG_GLOB,
    (configFilePath, options, context) => {
        devkit_1.logger.warn('`createNodes` is deprecated. Update your plugin to utilize createNodesV2 instead. In Nx 20, this will change to the createNodesV2 API.');
        return internalCreateNodes(configFilePath, options, context, {});
    },
];
function getProjectsUsingESLintConfig(configFilePath, childProjectRoots, eslintVersion, options, context) {
    const projects = {};
    const rootEslintConfig = [
        config_file_1.baseEsLintConfigFile,
        config_file_1.baseEsLintFlatConfigFile,
        ...config_file_1.ESLINT_CONFIG_FILENAMES,
    ].find((f) => (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, f)));
    // Add a lint target for each child project without an eslint config, with the root level config as an input
    for (const projectRoot of childProjectRoots) {
        let standaloneSrcPath;
        if (projectRoot === '.' &&
            (0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'package.json'))) {
            if ((0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'src'))) {
                standaloneSrcPath = 'src';
            }
            else if ((0, node_fs_1.existsSync)((0, node_path_1.join)(context.workspaceRoot, projectRoot, 'lib'))) {
                standaloneSrcPath = 'lib';
            }
        }
        if (projectRoot === '.' && !standaloneSrcPath) {
            continue;
        }
        const eslintConfigs = [configFilePath];
        if (rootEslintConfig && !eslintConfigs.includes(rootEslintConfig)) {
            eslintConfigs.unshift(rootEslintConfig);
        }
        projects[projectRoot] = {
            targets: buildEslintTargets(eslintConfigs, eslintVersion, projectRoot, context.workspaceRoot, options, standaloneSrcPath),
        };
    }
    return projects;
}
function buildEslintTargets(eslintConfigs, eslintVersion, projectRoot, workspaceRoot, options, standaloneSrcPath) {
    const isRootProject = projectRoot === '.';
    const targets = {};
    const targetConfig = {
        command: `eslint ${isRootProject && standaloneSrcPath ? `./${standaloneSrcPath}` : '.'}`,
        cache: true,
        options: {
            cwd: projectRoot,
        },
        inputs: [
            'default',
            // Certain lint rules can be impacted by changes to dependencies
            '^default',
            ...eslintConfigs.map((config) => `{workspaceRoot}/${config}`.replace(`{workspaceRoot}/${projectRoot}`, isRootProject ? '{projectRoot}/' : '{projectRoot}')),
            ...((0, node_fs_1.existsSync)((0, node_path_1.join)(workspaceRoot, projectRoot, '.eslintignore'))
                ? ['{projectRoot}/.eslintignore']
                : []),
            '{workspaceRoot}/tools/eslint-rules/**/*',
            { externalDependencies: ['eslint'] },
        ],
        outputs: ['{options.outputFile}'],
    };
    // Always set the environment variable to ensure that the ESLint CLI can run on eslint v8 and v9
    const useFlatConfig = eslintConfigs.some((config) => (0, config_file_1.isFlatConfig)(config));
    // Flat config is default for 9.0.0+
    const defaultSetting = (0, semver_1.gte)(eslintVersion, '9.0.0');
    if (useFlatConfig !== defaultSetting) {
        targetConfig.options.env = {
            ESLINT_USE_FLAT_CONFIG: useFlatConfig ? 'true' : 'false',
        };
    }
    targets[options.targetName] = targetConfig;
    return targets;
}
function normalizeOptions(options) {
    options ??= {};
    options.targetName ??= 'lint';
    // Normalize user input for extensions (strip leading . characters)
    if (Array.isArray(options.extensions)) {
        options.extensions = options.extensions.map((f) => f.replace(/^\.+/, ''));
    }
    else {
        options.extensions = DEFAULT_EXTENSIONS;
    }
    return options;
}
/**
 * Determines if `child` is a subdirectory of `parent`. This is a simplified
 * version that takes into account that paths are always relative to the
 * workspace root.
 */
function isSubDir(parent, child) {
    if (parent === '.') {
        return true;
    }
    parent = (0, node_path_1.normalize)(parent);
    child = (0, node_path_1.normalize)(child);
    if (!parent.endsWith(node_path_1.sep)) {
        parent += node_path_1.sep;
    }
    return child.startsWith(parent);
}
